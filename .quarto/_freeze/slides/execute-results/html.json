{
  "hash": "90511220f9002433684726a89da956f5",
  "result": {
    "markdown": "---\ntitle: \"spatialsample:\"\nsubtitle: \"A tidy approach to spatial cross-validation\"\nauthor:\n  - name: \"**Michael J Mahoney**\"\n    orcid: 0000-0003-2402-304X\n    email: mjmahone@esf.edu\n    url: https://mm218.dev\nformat: \n  revealjs: \n    standalone: true\n    center: true\n    slide-number: false\n    overview: true\n    width: 1280\n    height: 720\n    theme: [default, custom.scss]\n    footer: \"spatialsample: A tidy approach to spatial cross-validation - https://mm218.dev/boston_useR_2023\"\n---\n\n\n\n\n## About Me\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n\n- Mike Mahoney\n\n- PhD candidate in environmental science\n\n- 2022 summer intern with Posit (spatialsample, rsample)\n\n- These slides: [mm218.dev/boston_useR_2023](https://mm218.dev/boston_useR_2023)\n\n:::\n\n::: {.column width=\"10%\"}\n:::\n\n::: {.column width=\"40%\"}\n\n![](me.jpeg)\n\n:::\n::::\n\n:::{.notes}\nBefore I get into that, I want to introduce myself quickly -- I'm Mike and I'm currently a PhD candidate in environmental science, but the work I'm going to talk about today actually comes from this past summer when I was an intern with the tidymodels team at Posit working on cross validation in tidymodels.\n:::\n\n## Data splitting:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](slides_files/figure-revealjs/data_split-1.svg){width=960}\n:::\n:::\n\n\n::: footer\nFigure adapted from <a href=\"https://workshops.tidymodels.org/\">https://workshops.tidymodels.org/</a>\n\nspatialsample: A tidy approach to spatial cross-validation - https://mm218.dev/boston_useR_2023\n:::\n\n---\n\n![](modeling-process.svg)\n\n::: footer\nImage from <a href=\"https://www.tmwr.org/software-modeling.html\">https://www.tmwr.org/software-modeling.html</a>\n\nspatialsample: A tidy approach to spatial cross-validation - https://mm218.dev/boston_useR_2023\n:::\n\n## Cross-validation:\n\n\n::: {.cell animation.hook='gifski'}\n::: {.cell-output-display}\n![](slides_files/figure-revealjs/vfold_gif-.gif){width=960}\n:::\n:::\n\n\n:::{.notes}\nAnd for anyone who isn't familiar, cross validation is a model assessment approach that helps you understand how well your model will predict new data that it hasn't seen before. Normally you'll evaluate your final models against an independent test set, which isn't involved in the model fitting process at all. But if you want to evaluate models that you're still iterating on, you'll normally split your training data into a handful of what we call \"folds\". You then usually train your model on all but one of those folds, and evaluate it against that final fold, in order to get a sense of how well your intermediate models will do on independent data. Then, when you're finished iterating, you'll train your model on all those folds together and evaluate it against the independent test set.\n:::\n\n::: footer\nFigure adapted from <a href=\"https://workshops.tidymodels.org/\">https://workshops.tidymodels.org/</a>\n\nspatialsample: A tidy approach to spatial cross-validation - https://mm218.dev/boston_useR_2023\n:::\n\n## rsample and friends\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidymodels)\nrsample::vfold_cv(spatialsample::boston_canopy) |> head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> # A tibble: 6 × 2\n#>   splits           id    \n#>   <list>           <chr> \n#> 1 <split [613/69]> Fold01\n#> 2 <split [613/69]> Fold02\n#> 3 <split [614/68]> Fold03\n#> 4 <split [614/68]> Fold04\n#> 5 <split [614/68]> Fold05\n#> 6 <split [614/68]> Fold06\n```\n:::\n:::\n\n\n<br />\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworkflow() |> \n  add_model(linear_reg()) |> \n  add_formula(canopy_area_2019 ~ land_area * mean_temp) |> \n  fit_resamples(vfold_cv(spatialsample::boston_canopy)) |> \n  collect_metrics()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> # A tibble: 2 × 6\n#>   .metric .estimator       mean     n    std_err .config             \n#>   <chr>   <chr>           <dbl> <int>      <dbl> <chr>               \n#> 1 rmse    standard   377089.       10 20426.     Preprocessor1_Model1\n#> 2 rsq     standard        0.353    10     0.0178 Preprocessor1_Model1\n```\n:::\n:::\n\n\n:::{.notes}\nAnd there's this tidymodels package called rsample that handles that splitting process for you. And the objects that rsample functions return can be used with functions from across the tidymodels ecosystem, which makes it easy to use cross-validation as part of any modeling workflow you might want.\n:::\n\n## What does \"new data\" mean?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(spatialsample::boston_canopy, aes(fill = canopy_area_2019)) + geom_sf() + \n  scale_fill_distiller(name = \"Canopy area (2019)\", palette = \"YlGn\", direction = 1)\n```\n\n::: {.cell-output-display}\n![](slides_files/figure-revealjs/unnamed-chunk-3-1.svg){width=960}\n:::\n:::\n\n\n:::{.notes}\nBut a challenge is that most rsample functions assume you can assign your data to folds at random, and still get independent training and test sets. That's true for a lot of data, but starts to break down once your data is no longer entirely independent -- once you start getting autocorrelation between your observations. And for spatial data, you almost always have autocorrelation. For instance, this is a map of tree cover in Boston, and as you can kinda guess tree cover isn't randomly distributed across the city -- down in Stony Brook Park there's a ton of tree cover, up here in Seaport there's a bit less. The tree cover for any one of these hexagons is pretty tightly linked to how much tree cover its neighbors have.\n:::\n\n## Are these folds really unrelated?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrsample::vfold_cv(spatialsample::boston_canopy, v = 5)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](slides_files/figure-revealjs/first_vfold-1.svg){width=960}\n:::\n:::\n\n\n:::{.notes}\nAnd so if you split this up at random, you're going to get pretty highly related training and testing sets, which is probably going to make your model assessments way too optimistic. Your training and testing sets are so similar that you're practically testing with training data.\n:::\n\n---\n\n![](https://raw.githubusercontent.com/rstudio/hex-stickers/main/PNG/spatialsample.png){.quarto-figure-center}\n\n:::{.notes}\nSo this is where spatialsample comes in. spatialsample is a newer tidymodels package that helps you do spatial cross-validation, where you assign data to folds based on its spatial location rather than just at random.\n:::\n\n## Spatial clustering\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(spatialsample)\nset.seed(1234)\nspatial_clustering_cv(boston_canopy, v = 5)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](slides_files/figure-revealjs/boston_clusters-1.svg){width=960}\n:::\n:::\n\n\n:::{.notes}\nSo to give you a sense of what that looks like, this is the output from the spatial_clustering_cv() function. You can see that rather than having our folds all mixed in together, we're assigning folds based on where each of these hexagons are located.\n:::\n\n## Spatial clustering\n\n\n::: {.cell animation.hook='gifski'}\n\n```{.r .cell-code}\nlibrary(purrr)\nwalk(spatial_clustering_cv(boston_canopy, v = 5)$splits, function(x) print(autoplot(x)))\n```\n\n::: {.cell-output-display}\n![](slides_files/figure-revealjs/boston_clusters_gif-.gif){width=960}\n:::\n:::\n\n\n:::{.notes}\nAnd so rather than training and testing with random data, we're testing on data that's geographically separated from our training data, and so hopefully less related to the testing data.\n:::\n\n## Spatial blocking\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspatial_block_cv(boston_canopy, v = 5, n = c(10, 10))\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](slides_files/figure-revealjs/boston_blocks-1.svg){width=960}\n:::\n:::\n\n\n:::{.notes}\nThere's a handful of other methods in spatialsample that are also useful; for instance, spatial_block_cv() lets you split your data up using a regular grid, which is a super popular method in ecology studies.\n:::\n\n## Spatial blocking\n\n\n::: {.cell animation.hook='gifski'}\n\n```{.r .cell-code}\nwalk(spatial_block_cv(boston_canopy, v = 5, n = c(10, 10))$splits,\n     function(x) print(autoplot(x)))\n```\n\n::: {.cell-output-display}\n![](slides_files/figure-revealjs/boston_block_gif-.gif){width=960}\n:::\n:::\n\n\n## Spatial blocking\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspatial_block_cv(boston_canopy, v = 5, n = c(10, 10), \n                 method = \"continuous\", relevant_only = FALSE)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](slides_files/figure-revealjs/boston_blocks_continuous-1.svg){width=960}\n:::\n:::\n\n\n## Spatial LODO\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfolds <- spatial_buffer_vfold_cv(boston_canopy, v = Inf, radius = 1500, buffer = 1500)\nwalk(folds$splits, function(x) print(autoplot(x)))\n```\n:::\n\n::: {.cell animation.hook='gifski'}\n::: {.cell-output-display}\n![](slides_files/figure-revealjs/boston_vfold_all_gif-.gif){width=960}\n:::\n:::\n\n\n:::{.notes}\nAnd we've also got a method we call \"leave one disc out\", or LODO, where you use all the observations within a certain distance of some point as your test set, and leave all the points within a \"buffer\" distance of that out entirely. And that buffer is really useful to make sure that you aren't including correlated points in both your training and testing data.\n:::\n\n\n## Buffering\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspatial_clustering_cv(boston_canopy, v = 5, buffer = 1500)\n```\n:::\n\n::: {.cell animation.hook='gifski'}\n::: {.cell-output-display}\n![](slides_files/figure-revealjs/boston_clusters_buffer_gif-.gif){width=960}\n:::\n:::\n\n\n:::{.notes}\nAnd so rather than training and testing with random data, we're testing on data that's geographically separated from our training data, and so hopefully less related to the testing data.\n:::\n\n## tidymodels integration\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworkflow() |> \n  add_model(linear_reg()) |> \n  add_formula(canopy_area_2019 ~ land_area * mean_temp) |> \n  fit_resamples(vfold_cv(spatialsample::boston_canopy)) |> \n  collect_metrics()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> # A tibble: 2 × 6\n#>   .metric .estimator       mean     n    std_err .config             \n#>   <chr>   <chr>           <dbl> <int>      <dbl> <chr>               \n#> 1 rmse    standard   378993.       10 18001.     Preprocessor1_Model1\n#> 2 rsq     standard        0.354    10     0.0171 Preprocessor1_Model1\n```\n:::\n:::\n\n\n<br/>\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworkflow() |> \n  add_model(linear_reg()) |> \n  add_formula(canopy_area_2019 ~ land_area * mean_temp) |> \n  fit_resamples(spatial_clustering_cv(spatialsample::boston_canopy)) |> \n  collect_metrics()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> # A tibble: 2 × 6\n#>   .metric .estimator       mean     n     std_err .config             \n#>   <chr>   <chr>           <dbl> <int>       <dbl> <chr>               \n#> 1 rmse    standard   934397.       10 549480.     Preprocessor1_Model1\n#> 2 rsq     standard        0.348    10      0.0468 Preprocessor1_Model1\n```\n:::\n:::\n\n\n---\n\n![](fig-comparisons-1.png){.quarto-figure-center}\n\n<br />\n\n::: {style=\"font-size: medium;\"}\nMahoney, MJ, Johnson, L. K., Silge, J., Frick, H., Kuhn, M., and Beier, C. M. In Review. Assessing the performance of spatial cross-validation approaches for models of spatially structured data. [https://doi.org/10.48550/arXiv.2303.07334](https://doi.org/10.48550/arXiv.2303.07334)\n:::\n\n:::{.notes}\nAnd these methods are all typically going to give you a more accurate model assessment when you're working with spatial data than non-spatial cross-validation. This graph is from a preprint we put out last month -- that green zone is the \"target\" range for RMSE, and you can see that clustered, LODO, and blocked all have more of their distribution in the green zone than normal V-fold cross-validation. \n:::\n\n## Other features:\n\n<br />\n\n{{< fa square-check >}} Works with projected & geographic CRS\n\n{{< fa square-check >}} Arguments accept explicit units\n\n{{< fa square-check >}} Aware of CRS units, functions do unit conversion\n\n{{< fa square-check >}} Handles all geometry types$^*$\n\n:::{.notes}\nAnd last but not least, I wanted to mention that spatialsample is really designed around the idea of helping users fall into what you'd call a pit of success, and so handles a lot of the common edge cases that come up with spatial data -- spatialsample can work with geographic coordinates, with mismatched coordinate reference systems, with different units, with points, polygons, and lines, and generally does what you'd hope spatial software would do. And by building on top of rsample, the objects and functions from spatialsample automatically integrate with the rest of the tidymodels ecosystem too.\n:::\n\n## Thank you!\n\n<br />\n\n#### Find me online:\n\n{{< fa globe >}} [mm218.dev](https://mm218.dev) \n\n{{< fa brands github >}} @mikemahoney218 \n\n<i class=\"fab fa-mastodon\"></i> [@MikeMahoney218@fosstodon.org](https://fosstodon.org/@MikeMahoney218)\n\n<br />\n\nSlides available at [mm218.dev/boston_useR_2023](https://mm218.dev/boston_useR_2023)\n\nMore spatialsample: [https://spatialsample.tidymodels.org/](https://spatialsample.tidymodels.org/)\n\n:::{.notes}\nSo, with that, I want to say thanks! If you have any questions or just want to talk, feel free to say hi after; otherwise, you can find me online at MikeMahoney218 or my website, mm218 dot dev. Thanks!\n:::\n",
    "supporting": [
      "slides_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}